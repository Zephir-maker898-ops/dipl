# Exploit Methods

So this is a listing of all of the various attacks remenissions can do. I grouped similar attacks together in "attack classes". There is stuff referenced from other docs.

# BofVar

This class includes these attacks:

```
BofVar
```

So this attack primarily focuses on overflowing a variable, to redirect code execution (that sweet sweet branch analysis). Something like this:

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{

    char buf[50];
    int target0;
    int target1;

    gets(buf);

    if (target0 == 0xfacade)
    {
        system("/bin/sh");
    }

    if (target1 == 0xfacade)
    {
        system("/bin/sh");
    }
}
```

In this instance, we leverage the `gets` bug to overwrite either the `target0` variable to `0xfacade`, `target1` to `0xfacade`, or both to `0xfacade`. Effectively how this attack works, is first we identify a stack overflow bug with the static analyzer. Then we scan through the rest of the function, looking for a compare with a variable that we can reach with our overflow (we assume linear control flow). Then once we get to a check that we can actually influence, we try to see which branch we should take. We do this by looking at each branch. If we see a designated libc "win function" like a call to `system("/bin/sh")` or a function that has been designated as an alternate win function (because it does something like call `system("/bin/sh")` or open `flag.txt`), we designate that as branch we want to take. If we see a designated libc loose function like `exit(0)` we designate that as the branch we don't want to take. In the situation where we can't see what path we want to take, then we just mark the desired path as unknown.

Now with the branch analysis we use to solve this type of problem, it is very good at determining what type of check is happening to what type of variable. Now where it sometimes get's things wrong is with predicting which branch we want to take. As such for correction, we effectively just brute force all possible code paths. Since branch analysis is really good at determining what type of check it is, against what value, we can accurately generate two values that will make the check either pass or fail, effectively turning it into a boolean choice for us. From a practicality standpoint, the desired ctf targets won't have a lot of checks like this, so we can do it in a reasonable amount of time. By having this be the correction, it doesn't matter how good or bad branch analysis is with predicting which branches we should take and which we shouldn't, we will get the right path if it is this type of problem, it's just a matter of when.

One last thing, the branch analysis aspect here is present in basically all attacks that rely on stack overflow. This is because we will see things like this:

```
#include <stdio.h>
#include <stdlib.h>

void win(void)
{
    system("/bin/sh");
}

void main(void)
{
    char vuln[20];
    int var0;
    fgets(vuln, 100, stdin);

    if (var0 != 0xfacade)
    {
        exit(0);
    }


}
```

Here we will overflow the return address to call `win`. However if we don't overwrite `var0` to be `0xfacade` then we won't hit that return. As such branch analysis is needed here, and is incorporated into basically every type of stack overflow attack.

# BofFunc

This class includes these attacks:

```
BofFunc
BofFuncArgv
BofFuncWInfoleak
BofSystem
BofSystemWInfoleak
```

So what these attacks focus on, is overflowing the return address to a function. The functions here are either a `"win function"` or libc `system` if it's imported into the binary. Now for the win functions, I check for this with the static analyzer as part of checking for alternate win conditions. Effectively I check all of the PIE functions to see if any of them calls a potential win function like `system` or `fopen`, with arguments that would lead me to believe that it could be a win function. I also have attacks which are specified for argv input, instead of stdin input. Here is an example of a challenge:

```
#include <stdio.h>
#include <stdlib.h>

void win(void)
{
    system("/bin/sh");
}

int main(void)
{
    char hi[20];
    gets(hi);
}
```

Now if `system` is imported, I have attacks to call it via rop. Here is an example of one. In addition to `system` being imported, a string like `/bin/sh` has to exist in the binary at an address we can figure out:

```
#include <stdio.h>
#include <stdlib.h>

char *binsh0 = "set me free";
char *binsh1 = "/bin/sh";

void systemFunct(void)
{
        system("echo 'hi'");
}

void vuln(void)
{
    char hi[20];
    fgets(hi, 100, stdin);
}    


void main(void)
{
    vuln();
}
```

Now I also have attacks that are for if PIE is enabled. It expects an infoleak to be given, so it can figure out the pie addresses, like this. Here we get a PIE infoleak where it prints the address of `pie`:

```
#include <stdio.h>
#include <stdlib.h>

void win(void)
{
    system("/bin/sh");
}

int main(void)
{
    char hi[20];
    printf("The sin, and the sentence: %p\n", main);
    gets(hi);
}
```

Now for correction for these attacks, for the one that uses win functions. I cycle through two things. The first thing is all of the win functions, the alternate win function detected, and the second are all of the variables that come from the branch analysis. That way if we have code like this where there could potentially be multiple functions marked as a win function incorrectly, we can hit the right one.

```
#include <stdio.h>
#include <stdlib.h>

void falseWin0(void)
{
    system("trashed and scattered");
}

void win(void)
{
    system("/bin/sh");
}

void falseWin1(void)
{
    system("people = shit");
}

void falseWin2(char inp)
{
    system(inp);
}

void vuln(void)
{
    char vuln[20];

    fgets(vuln, 100, stdin);

}

void main(void)
{
    vuln();
}
```

# BofShellcode

This class includes these attacks:

```
BofShellcode
```

So what this attack revolves around as you can probably guess, overflowing the return address to point to shellcode on the stack (requires NX to be disabled). This requires a stack infoleak which is given. In addition to that, the main difference between this and the `BofFunc` attacks, is that we have to place shellcode on the stack. Here is a basic example of a target that can be landed with this type of attack:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf[100];

    printf("Stack Infoleak: %p\n", buf);
    gets(buf);
}

void main(void)
{
    vuln();
}
```

Now the tricky part here that comes in is branch analysis. Where do we place our shellcode on the stack, if there are also variables on the stack that we need to have set to certain values for branch analysis. In this case, there are three different places I will place the shellcode. The first is between variables that have checks like in this instance.

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf[10];
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14;
    

    printf("Stack Infoleak: %p\n", buf);

    t1 = t2 = t3 = t4 = t5 = t6 = t7 = t8 = t9 = t10 = t11 = t12 = t13 = t14 = 0xdead;


    fgets(buf, 124, stdin);


    if ((t0 != 0xfacade) && (t14 != 0xfacade))
    {
        exit(0);
    }
}

void main(void)
{
    vuln();
}
```

The second is after the return address, like in this instance:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf0[2];
    char buf1[2];
    

    printf("Stack Infoleak: %p\n", buf1);

    fgets(buf0, 124, stdin);
}

void main(void)
{
    vuln();
}
```

The third is if neither of the above two options is practical, then I will simply overwrite variables with checks with my shellcode, like in this instance:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf0[2];
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15;

    t0 = t1 = t2 = t3 = t4 = t5 = t6 = t7 = t8 = t9 = t10 = t11 = t12 = t13 = t14 = t15 = 0xdead;

    printf("Stack Infoleak: %p\n", buf0);

    fgets(buf0, 83, stdin);

    if ((t0 == t1) && (t2 == t3) && (t4 == t5) && (t6 == t7) && (t8 == t9) && (t10 == t11) && (t12 == t13) && (t14 == t15) && (t15 == 0xdead))
    {
        puts("Bring the broken back to life.");
    }

}

void main(void)
{
    vuln();
}
```

Now one thing about this type of attack, is one shellcode will not fit all cases. You may need shellcode that meets a size requirement, cleans up the stack/registers, or doesn't use certain bytes to be scanned in correctly. As such I have a variety of shellcodes to meet different use cases, and as part of correction I will cycle through the various shellcodes for that architecture.

# IndrCall

This class includes these attacks:

```
IndrCall
IndrCallPie
IndrCallLibc
IndrCallShellcode
```

So these attacks revolve around overwriting a ptr on the stack, which is indirectly called. I find indirectly called ptrs via as I am scanning through for checks, I also check for indirectly called ptrs on the stack, that our buffer overflow can reach. This is an example of one:

```
#include <stdio.h>
#include <stdlib.h>


void pwn(void)
{
    system("/bin/sh");
}

void main(void)
{

    char buf0[20];
    volatile int (*ptr)();
    char buf1[200];

    fgets(buf0, 100, stdin);

    ptr();

}
```

In this instance, we overwrite `ptr` which is indirectly called to point to the win function `pwn`. We also have support for this same attack, but with PIE enabled, assuming we get a PIE infoleak like this:

```
#include <stdio.h>
#include <stdlib.h>


void pwn(void)
{
    system("/bin/sh");
}

void main(void)
{

    char buf0[20];
    volatile int (*ptr)();
    char buf1[200];

    printf("Don't live your life in shame: %p\n", main);
    fgets(buf0, 100, stdin);

    ptr();

}
```

Now the next attack revolves around overwriting an indirectly called ptr to point to shellcode on the stack. How it places the shellcode is similar to the `BofShellcode` attack. Of course it requires NX to be disbaled, and a stack infoleak to be given.

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{

    char buf0[50];
    volatile int (*ptr)();
    char buf1[200];

    printf("What the dead men say: %p\n", buf0);

    fgets(buf0, 100, stdin);

    ptr();

}
```

Now the last attack revolves around overwriting an indirectly called ptr to a one gadget. Since we probably don't have control over anything other than the address which is called, one gadgets are perfect here. It requires a libc infoleak to be given, as well as a libc file the challenge has. It only is available for `64` bit binaries, since one gadgets for `32` bit binaries require a bit more setup.

```
#include <stdio.h>
#include <stdlib.h>


void pwn(void)
{
    system("/bin/sh");
}

void main(void)
{

    char buf0[20];
    volatile int (*ptr)();
    char buf1[200];

    printf("Don't live your life in shame: %p\n", printf);
    fgets(buf0, 100, stdin);

    ptr();

}
```
# CallInput

This class includes these attacks:

```
CallInput
```

Effectively this attack revolves around our input being called as instructions. It's pretty simple. Here is an example:

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{
    char input[200];
    fgets(input, sizeof(input), stdin);
    (*(void (*)()) input)();
}
```

The input does not need to be stored on the stack:

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void main(void)
{
    void *inp;
    inp = mmap(0, 200, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, 0, 0);
    fgets(inp, 200, stdin);
    (*(void (*)()) inp)();
}
```

The `CallInput` bug is found via the dynamic analyzer. I did not initially plan on including this attack, however I found too many ctf challenges like this, so I decided to add it. The input I give is effectively just shellcode. For correction I just cycle through different shellcodes.

# Ret2Static

This class includes these attacks:

```
BofStatic
```

So this attack is the only attack which revolves around statically compiled binaries. Effectively it is we have a buffer overflow with a statically compiled binary. We overwrite the return address with a rop chain from the pie section (we assume pie is disabled). Here is an example:

```
#include <stdio.h>
#include <stdlib.h>


void vuln(void)
{
    char buf[0x50];
    gets(buf);
}

void main(void)
{
    vuln();
}
```

Now out of all of the attacks remenissions has, this one is the least flushed out. I only have support for `x64` attacks, and in addition to that, I only have support for one rop chain, so if it doesn't have those gadgets, it can't land the attack.

# Ret2Libc

This class includes these attacks:

```
Ret2Libc
Ret2LibcPutsInfoleak
IdLibcPutsInfoleak
```

So these attacks revolve around overwriting the return address, to execute code from libc. Where these attacks differ, is how much information we are given. With `Ret2Libc` we are given both the libc file and a libc infoleak, like this:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf0[20];

    printf("I live to fight another: %p\n", printf);
    gets(buf0);
}

void main(void)
{
    vuln();
}
```

Now for the next type of attack, we are given a libc file, but we have to use `puts` to get the libc infoleak, like this. We call main afterwards to then overwrite the return address to libc:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
    char buf[50];


    printf("Silence in the Snow!\n");
    gets(buf);
}

void main(void)
{
    vuln();
}
```

The last type of attack here, is by far the most useful attack remenissions has. It will remotely identify the libc version, using an infoleak it makes with `puts` using `TheNight`. After it finds the remote libc version (or versions, if there are multiple matches) it basically runs the above attack on it. The reason why this is so useful, isn't that there are many challenges like this. It is the fact that this is an unintentional solution to a lot of different ctf challenges.

# FmtString

This class includes these attacks. Not all of these are going to pretty practical for ctf challenges, but I wanted the autopwner to have the functionality for these attacks:

```
FsGotWinFunc
FsGotWinFuncPie
FsGotWinFuncPieFsleak
FsGotSystem
FsGotSystemPie
FsRetWinFunc
FsRetShellcode
FsGotShellcode
FsGotShellcodeFsleak
FsGotLibc
FsGotLibcFsleakLoop
FsGotOneshot
```

All of these attacks revolve around format strings. The main difference between them is what they are overwriting, what region of memory the code they want to execute, and if they need infoleaks (and how they are getting them). For what we are overwriting, these attacks either overwrite the return address or a got address. For what code we execute, it is either a pie function, shellcode on the stack, or libc code. For infoleaks, I have it where it can either take a given infoleak, or it can leverage the fmt string to get an infoleak (for both pie, stack, and libc). Now when it leverages a fmt string for a leak, it uses the dynamic analyzer to see where the closest address on the stack is in relation to the format string, then leaks that. Also each fmt string bug is tied to an input, whether that input is just an input or a stack overflow bug.

First off, we have the fmt string attacks which revolve around pie:

```
FsGotWinFunc
FsGotWinFuncPie
FsGotWinFuncPieFsleak
FsGotSystem
FsGotSystemPie
```

All of these attacks revolve around overwriting a got function, to point to a pie win function. Here is an example:

```
#include <stdio.h>
#include <stdlib.h>


void pwned(void)
{
    system("/bin/sh");
}

void main(void)
{
    char buf[100];

    fgets(buf, sizeof(buf), stdin);

    printf(buf);

    fflush(stdin);
}
```

Here it will overwrite the got address of `fflush` to point to `pwned`.

In addition to that, there is also support for overwriting a function's got to point to main to get an infinite loop, then overwriting `printf`'s got address to imported libc `system`, then leverage that to call `system("/bin/sh")`. There is also support for given pie infoleaks, both for the previous attack and this:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <sys/syscall.h>

void notPwned(void)
{
    system("/bin/ls");
}

void main(void)
{
    char buf[100];
    int v0, v1, v2;

        printf("It seems I've been buried alive: %p\n", printf);

    fgets(buf, sizeof(buf), stdin);

    printf(buf);

    exit(0);
}
```

Next up, this is the attack that leverages a fmt string for a pie infoleak. Since we don't know the pie memory space when we first hit the printf, we have to assume that it is in a loop:

```
#include <stdio.h>
#include <stdlib.h>

void pwned()
{
    system("/bin/sh");
}

void vuln(void)
{
        char buf[500];

        fgets(buf, sizeof(buf), stdin);

        printf(buf);

    fflush(stdin);
}

void main(void)
{
    int i;
    for (i = 0; i < 3; i++)
    {
        vuln();
    }
}
```

Next up we have the attacks that revolve around a stack infoleak, which all of these require.

```
FsRetWinFunc
FsRetShellcode
FsGotShellcode
FsGotShellcodeFsleak
```

So for the `FsRetWinFunc` attack, this revolves around overwriting the return address to point to shellcode on the stack:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
        char buf[500];

        printf("Tell me I was never good enough: %p\n", buf);

        fgets(buf, sizeof(buf), stdin);

        printf(buf);
}

void main(void)
{
    vuln();
}
```

The `FsRetWinFunc` is pretty much the same attack, except it overwrites the return address to a win function. The `FsGotShellcode` attack overwrites a got address to shellcode on the stack:

```
#include <stdio.h>
#include <stdlib.h>

void vuln(void)
{
        char buf[150];

        printf("Tell me I was never good enough: %p\n", buf);

        fgets(buf, sizeof(buf), stdin);

        printf(buf);

    exit(0);
}

void main(void)
{
    vuln();
}
```

The last attack `FsGotShellcodeFsleak` relies on first doing a got overwrite for an infinite loop, then using the next iteration to get a fmt string leak for the stack and store shellcode on the stack, then overwrite the got address again to point to the shellcode. Here is an example of source code where this attack applies:

```
#include <stdio.h>
#include <stdlib.h>


void vuln(void)
{
        char buf[500];

        fgets(buf, sizeof(buf), stdin);

        printf(buf);

    exit(0);
}

void main(void)
{
    vuln();
}
```

So lastly we have the libc based format string challenges. All of these require a libc file to be specified:

```
FsGotLibc
FsGotLibcFsleakLoop
FsGotOneshot
```

The `FsGotLibc` relies on overwriting a got address for an infinite loop, then overwriting `printf` to libc `system`, then using that to call `system("/bin/sh")`. It requires a libc infoleak to be given:

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{
    char buf[100];
    int v0, v1, v2;

        printf("It seems I've been buried alive: %p\n", printf);

    fgets(buf, sizeof(buf), stdin);

    printf(buf);

    exit(0);
```

The `FsGotOneshot` attack overwrites a got address to a libc oneshot gadget (because of that, it's only for `x64`). It relies on a libc infoleak be given:

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{
    char buf[100];
    int v0, v1, v2;

        printf("It seems I've been buried alive: %p\n", printf);

    fflush(stdin);

    fgets(buf, sizeof(buf), stdin);

    printf(buf);

    fflush(stdin);
}
```

The `FsGotLibcFsleakLoop` attack relies on leveraging a fmt string for a libc infoleak, then doing a got overwrite to libc `system`:

```
#include <stdio.h>
#include <stdlib.h>

void main(void)
{
    char buf[100];
    int i;

    for (i = 0; i < 3; i++)
    {
        fgets(buf, sizeof(buf), stdin);

        printf(buf);
    }
}
```
